# Map Diagnose 20250917-220647

## Git
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   package.json
	modified:   pnpm-lock.yaml
	modified:   src/components/location/AddressAutocomplete.tsx
	modified:   src/components/location/ProvinceCitySelect.tsx

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	src/app/api/geo/
	src/app/api/osm/
	src/components/MapView.tsx
	src/components/PlacesAutocompleteOSM.tsx
	src/components/PlacesAutocompletePhoton.tsx
	src/components/location/AddressAutocomplete.tsx.bak.20250916-220034
	src/components/location/ProvinceCitySelect.tsx.bak.20250916-220034
	src/lib/places.ts
	src/lib/search.ts
	src/lib/text.ts
	src/lib/zaIndex.ts
	transcript-20250917-220538.txt

no changes added to commit (use "git add" and/or "git commit -a")

* b7df30e (HEAD -> main, origin/main) Map: centre-on-pin + Leaflet icons + dynamic no-SSR import
* 7af0210 fix(geo): add aliases + robust Nominatim mapping; normalize city recenter; better suburb suggestions
* 9ae5aab fix(geo): add aliases + robust Nominatim mapping; normalize city recenter; better suburb suggestions


## Versions
Node: v22.18.0
pnpm: 10.15.1

## Packages
Legend: production dependency, optional only, dev only

cosmos-web@0.1.0 C:\Cosmos\Apps\TradePost (PRIVATE)

dependencies:
leaflet 1.9.4
react 19.1.0
react-dom 19.1.0
react-leaflet 5.0.0


## Find MapContainer/center=

src\components\MapView.tsx:5:import { MapContainer, TileLayer, Marker, Popup, useMap, useMapEvents } from "react-leaflet";
src\components\MapView.tsx:118:      <MapContainer center={center} zoom={6} style={{ height: "100%", width: "100%" }}>
src\components\MapView.tsx:160:      </MapContainer>



## src/app/search/page.tsx (first 160 lines)
"use client";

import { useState } from "react";
import dynamic from "next/dynamic";
import PlacesAutocompletePhoton, { type PickedPlace } from "@/components/PlacesAutocompletePhoton";

const MapView = dynamic(() => import("@/components/MapView"), { ssr: false });

export default function SearchPage() {
  const [picked, setPicked] = useState<PickedPlace | null>(null);
  const [text, setText] = useState<string>("");
  const [selectionToken, setSelectionToken] = useState(0);

  return (
    <div className="min-h-screen p-6 flex flex-col items-center gap-6">
      <div className="w-full max-w-3xl grid md:grid-cols-2 gap-6">
        <div>
          <label className="block text-sm font-medium mb-1">Search city / town / suburb / street</label>
          <PlacesAutocompletePhoton
            externalText={text}
            placeholder="Try: Durban · Bloemfontein · Sarel Cilliers St, Warden"
            onSelected={(p) => {
              setPicked(p);           // update chosen place
              setText(p.label);       // reflect text
              setSelectionToken(t => t + 1); // tell map it's a NEW selection
            }}
          />
          <div className="mt-2 text-[11px] text-neutral-600">
            <b>Fly target:</b> {picked?.label ?? "-"} · {picked?.lat?.toFixed(6)}, {picked?.lng?.toFixed(6)} · zoom {picked?.zoomHint ?? 14}
          </div>
        </div>

        <div>
          <div className="text-sm font-medium mb-1">Map (click to drop · drag to adjust)</div>
          <MapView
            lat={picked?.lat}
            lng={picked?.lng}
            label={picked?.label}
            selectionToken={selectionToken}
            selectZoom={picked?.zoomHint ?? 14}
            onMove={(next) => {
              if (typeof next.label === "string" && next.label.length > 0) {
                setText(next.label);
              } else if (typeof next.lat === "number" && typeof next.lng === "number") {
                setText(`${next.lat.toFixed(6)}, ${next.lng.toFixed(6)}`);
              }
              setPicked(prev => prev
                ? { ...prev, lat: next.lat, lng: next.lng, label: next.label ?? prev.label }
                : { id: `${next.lat},${next.lng}`, label: next.label ?? `${next.lat}, ${next.lng}`, lat: next.lat, lng: next.lng }
              );
            }}
          />
        </div>
      </div>

      <div className="text-xs text-neutral-500">
        New search → map flies & centers (no manual resize needed). Click/drag keeps your zoom. Labels are place-first.
      </div>
    </div>
  );
}


## src/components/map/LeafletMap.tsx (first 200 lines)
"use client";

import { MapContainer, TileLayer, Marker, useMap } from "react-leaflet";
import L from "leaflet";
import { useEffect, useMemo } from "react";
import "leaflet/dist/leaflet.css";

L.Icon.Default.mergeOptions({
  iconRetinaUrl: "/leaflet/marker-icon-2x.png",
  iconUrl: "/leaflet/marker-icon.png",
  shadowUrl: "/leaflet/marker-shadow.png",
});

function FlyAndCentre({
  target,
  zoom,
  offsetPx = [0, 0],
  duration = 0.8,
}: {
  target?: L.LatLngExpression;
  zoom?: number;
  offsetPx?: [number, number];
  duration?: number;
}) {
  const map = useMap();

  useEffect(() => {
    if (!map) return;
    const container = map.getContainer();
    map.whenReady(() => map.invalidateSize());
    const ro = new ResizeObserver(() => map.invalidateSize({ pan: true }));
    ro.observe(container);
    const onWin = () => map.invalidateSize({ pan: true });
    window.addEventListener("resize", onWin);
    return () => {
      ro.disconnect();
      window.removeEventListener("resize", onWin);
    };
  }, [map]);

  useEffect(() => {
    if (!map || !target) return;
    map.invalidateSize();
    map.flyTo(target, zoom ?? map.getZoom(), { duration });
    map.once("moveend", () => {
      if (offsetPx[0] || offsetPx[1]) map.panBy(offsetPx, { animate: true });
    });
  }, [map, target, zoom, duration, offsetPx]);

  return null;
}

export default function LeafletMap({
  initialCenter = [-28.74, 24.76],
  initialZoom = 6,
  selected,
  selectedZoom = 13,
  sidebarPx = 0,
}: {
  initialCenter?: [number, number];
  initialZoom?: number;
  selected?: [number, number] | null;
  selectedZoom?: number;
  sidebarPx?: number;
}) {
  const offset = useMemo<[number, number]>(() => [sidebarPx ? sidebarPx / 2 : 0, 0], [sidebarPx]);
  return (
    <div className="h-full w-full">
      <MapContainer
        center={initialCenter}
        zoom={initialZoom}
        style={{ height: "100%", width: "100%", minHeight: 300 }}
        whenReady={(e) => e.target.invalidateSize()}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution="© OpenStreetMap"
        />
        {selected && <Marker position={selected} />}
        <FlyAndCentre target={selected ?? undefined} zoom={selectedZoom} offsetPx={offset} />
      </MapContainer>
    </div>
  );
}

